<!DOCTYPE html>
<html>
<head>
<meta name="GENERATOR" content="lxr-1998-06-10: http://lxr.linux.no">
<link rel="icon" href="/mxr.png" type="image/png">
<title>mozilla-central mozilla/toolkit/crashreporter/tools/symbolstore.py</title>
<link rel='stylesheet' title='' href='http://mxr.mozilla.org/mozilla-central/style/style.css' type='text/css'>

<script src='http://mxr.mozilla.org/coloration.js'></script>
<script src='http://mxr.mozilla.org/script.js'></script>
</head>

<body   bgcolor="#FFFFFF" text="#000000"
	link="#0000EE" vlink="#551A8B" alink="#FF0000">

<table class=banner bgcolor="#000000" width="100%" border=0 cellpadding=0 cellspacing=0>
<tr><td><a class="logo" href="//www.mozilla.org/"><img
 src="//www.mozilla.org/images/mozilla-banner.gif" alt=""
 border=0 width=600 height=58></a></td></tr></table>

<table class=header border=0 cellpadding=12 cellspacing=0 width="100%">
 <tr>
  <td align=left valign=middle>
   <nobr><font size="+2"><b><a href="http://mxr.mozilla.org">Mozilla Cross-Reference</a></b>
</nobr><i><a href="http://mxr.mozilla.org/mozilla-central">mozilla-central</a></i>
</font>
   <br><b><a href="/mozilla-central/source/">mozilla</a>/ <a href="/mozilla-central/source/toolkit/">toolkit</a>/ <a href="/mozilla-central/source/toolkit/crashreporter/">crashreporter</a>/ <a href="/mozilla-central/source/toolkit/crashreporter/tools/">tools</a>/ <a href="/mozilla-central/source/toolkit/crashreporter/tools/symbolstore.py">symbolstore.py</a> </b>
  </TD>

  <td align=right valign=top width="1%">
   <table border cellpadding=12 cellspacing=0>
    <tr>
     <td nowrap bgcolor="#FAFAFA">







<script>
function updateHgBlameHash(node, event) {
  if (!document.location.hash)
    return;
  var anchor = document.location.hash;
  anchor = anchor.replace("#", "#l");
  node.href =
    node.href.replace(/#.*|$/, anchor);
}
</script>
<a href="http://hg.mozilla.org/mozilla-central/filelog/9e03cd21db08/toolkit/crashreporter/tools/symbolstore.py">Hg Log</a><br>
<a href="http://hg.mozilla.org/mozilla-central/annotate/9e03cd21db08/toolkit/crashreporter/tools/symbolstore.py"
onfocus='updateHgBlameHash(this, event)'
onmouseover='updateHgBlameHash(this, event)'
>Hg Blame</a><br>



      <a href="http://mxr.mozilla.org/mozilla-central/diff?file=/toolkit/crashreporter/tools/symbolstore.py">Diff file</a><br>
      <a href="http://mxr.mozilla.org/mozilla-central/source/toolkit/crashreporter/tools/symbolstore.py?raw=1">Raw file</a><br>
     </TD>
    </TR>
   </table>
  </TD>



 </TR>
</table>

<form name='source' id='source' class='beforecontent'
>view using tree:
<select name='tree' id='tree' onchange='changetarget("http://mxr.mozilla.org/mozilla-central/", "mozilla-central/")'>
<option value="classic">classic</option>
<option value="firefox">firefox</option>
<option value="js">js</option>
<option value="mozilla">mozilla</option>
<option value="mozilla-aurora">mozilla-aurora</option>
<option value="mozilla-b2g18">mozilla-b2g18</option>
<option value="mozilla-beta">mozilla-beta</option>
<option value="mozilla-central" selected=1>mozilla-central</option>
<option value="mozilla-esr10">mozilla-esr10</option>
<option value="mozilla-esr17">mozilla-esr17</option>
<option value="mozilla-esr24">mozilla-esr24</option>
<option value="mozilla-release">mozilla-release</option>
<option value="mozilla1.9.1">mozilla1.9.1</option>
<option value="mozilla1.9.2">mozilla1.9.2</option>
<option value="mozilla2.0">mozilla2.0</option>
<option value="nspr-cvs">nspr-cvs</option>
<option value="seamonkey">seamonkey</option>
<option value="security">security</option>

</select></form>



<pre lang='en'><script>window.use_js_coloration = true;
window.ident_cgi='/mozilla-central/ident';
</script><noscript>Script has been disabled, please reload the page to see the scriptless version.</noscript><style>.d3:before{content:' '} .d2:before{content:'  '} .d1:before{content:'   '} .d0:before{content:'    '} </style><span id='the-code'><script>addCode("<C#!/bin/env python>\n<C><C# This Source Code Form is subject to the terms of the Mozilla Public>\n<C><C# License, v. 2.0. If a copy of the MPL was not distributed with this>\n<C><C# file, You can obtain one at <Lhttp://mozilla.org/MPL/2.0/.>>\n<C><C#>\n<C><C# Usage: symbolstore.py &lt;params&gt; &lt;dump_syms path&gt; &lt;symbol store path&gt;>\n<C><C#                                &lt;debug info files or dirs&gt;>\n<C><C#   Runs dump_syms on each debug info file specified on the command line,>\n<C><C#   then places the resulting symbol file in the proper directory>\n<C><C#   structure in the symbol store path.  Accepts multiple files>\n<C><C#   on the command line, so can be called as part of a pipe using>\n<C><C#   find &lt;dir&gt; | xargs symbolstore.pl &lt;dump_syms&gt; &lt;storepath&gt;>\n<C><C#   But really, you might just want to pass it &lt;dir&gt;.>\n<C><C#>\n<C><C#   Parameters accepted:>\n<C><C#     -c           : Copy debug info files to the same directory structure>\n<C><C#                    as sym files>\n<C><C#     -a \"&lt;archs&gt;\" : Run dump_syms -a &lt;arch&gt; for each space separated>\n<C><C#                    cpu architecture in &lt;archs&gt; (only on OS X)>\n<C><C#     -s &lt;srcdir&gt;  : Use &lt;srcdir&gt; as the top source directory to>\n<C><C#                    generate relative filenames.>\n<C>\n<Iimport> <a href='/mozilla-central/find?string=/sys\\.py$'>sys>\n<Iimport> <a href='/mozilla-central/find?string=/platform\\.py$'>platform>\n<Iimport> <a href='/mozilla-central/find?string=/os\\.py$'>os>\n<Iimport> <a href='/mozilla-central/find?string=/re\\.py$'>re>\n<Iimport> <a href='/mozilla-central/find?string=/shutil\\.py$'>shutil>\n<Iimport> <a href='/mozilla-central/find?string=/textwrap\\.py$'>textwrap>\n<Iimport> <a href='/mozilla-central/find?string=/fnmatch\\.py$'>fnmatch>\n<Iimport> <a href='/mozilla-central/find?string=/subprocess\\.py$'>subprocess>\n<Iimport> <a href='/mozilla-central/find?string=/urlparse\\.py$'>urlparse>\n<Iimport> <a href='/mozilla-central/find?string=/multiprocessing\\.py$'>multiprocessing>\n<Iimport> <a href='/mozilla-central/find?string=/collections\\.py$'>collections>\n<Ifrom> <a href='/mozilla-central/find?string=/optparse\\.py$'>optparse> import OptionParser\n<Ifrom> <a href='/mozilla-central/find?string=/minidom\\.py'>xml.dom.minidom> import parse\n\n<C# Utility classes>\n<C>\n<Vclass ><AVCSFileInfo>:\n    <S\"\"\" A base class for version-controlled file information. Ensures that the\n        following attributes are generated only once (successfully):\n\n            self.root\n            self.clean_root\n            self.revision\n            self.filename\n\n        The attributes are generated by a single call to the GetRoot,\n        GetRevision, and GetFilename methods. Those methods are explicitly not\n        implemented here and must be implemented in derived classes. \"\"\">\n\n    <Vdef ><D__init__>(<Dself>, <Dfile>):\n        <Vif ><Vnot ><Dfile>:\n            <Vraise ><AValueError>\n        <Dself>.<Dfile> = <Dfile>\n\n    <Vdef ><A__getattr__>(<Dself>, <Dname>):\n        <S\"\"\" __getattr__ is only called for attributes that are not set on self,\n            so setting self.[attr] will prevent future calls to the GetRoot,\n            GetRevision, and GetFilename methods. We don't set the values on\n            failure on the off chance that a future call might succeed. \"\"\">\n\n        <Vif ><Dname> == <S\"root\">:\n            <Droot> = <Dself>.<DGetRoot>()\n            <Vif ><Droot>:\n                <Dself>.<Droot> = <Droot>\n            <Vreturn ><Droot>\n\n        <Delif> <Dname> == <S\"clean_root\">:\n            <Aclean_root> = <Dself>.<AGetCleanRoot>()\n            <Vif ><Aclean_root>:\n                <Dself>.<Aclean_root> = <Aclean_root>\n            <Vreturn ><Aclean_root>\n\n        <Delif> <Dname> == <S\"revision\">:\n            <Drevision> = <Dself>.<AGetRevision>()\n            <Vif ><Drevision>:\n                <Dself>.<Drevision> = <Drevision>\n            <Vreturn ><Drevision>\n\n        <Delif> <Dname> == <S\"filename\">:\n            <Dfilename> = <Dself>.<DGetFilename>()\n            <Vif ><Dfilename>:\n                <Dself>.<Dfilename> = <Dfilename>\n            <Vreturn ><Dfilename>\n\n        <Vraise ><AAttributeError>\n\n    <Vdef ><DGetRoot>(<Dself>):\n        <S\"\"\" This method should return the unmodified root for the file or 'None'\n            on failure. \"\"\">\n        <Vraise ><ANotImplementedError>\n\n    <Vdef ><AGetCleanRoot>(<Dself>):\n        <S\"\"\" This method should return the repository root for the file or 'None'\n            on failure. \"\"\">\n        <Vraise ><ANotImplementedErrors>\n\n    <Vdef ><AGetRevision>(<Dself>):\n        <S\"\"\" This method should return the revision number for the file or 'None'\n            on failure. \"\"\">\n        <Vraise ><ANotImplementedError>\n\n    <Vdef ><DGetFilename>(<Dself>):\n        <S\"\"\" This method should return the repository-specific filename for the\n            file or 'None' on failure. \"\"\">\n        <Vraise ><ANotImplementedError>\n\n\n<C# This regex separates protocol and optional username/password from a url.>\n<C><C# For instance, all the following urls will be transformed into>\n<C><C# 'foo.com/bar':>\n<C><C#>\n<C><C#   <Lhttp://foo.com/bar>>\n<C><C#   svn+ssh://user@foo.com/bar>\n<C><C#   svn+ssh://user:pass@foo.com/bar>\n<C><C#>\n<C><ArootRegex> = <Dre>.<Dcompile>(<Dr><S'^\\S+?:/+(?:[^\\s/]*@)?(\\S+)$'>)\n\n<Vdef ><Aread_output>(*<Dargs>):\n    (<Dstdout>, <A_>) = <Dsubprocess>.<APopen>(<Dargs>=<Dargs>, <Dstdout>=<Dsubprocess>.<APIPE>).<Acommunicate>()\n    <Vreturn ><Dstdout>.<Drstrip>()\n\n<Vclass ><AHGRepoInfo>:\n    <Vdef ><D__init__>(<Dself>, <Dpath>):\n        <Dself>.<Dpath> = <Dpath>\n        <Drev> = <Aread_output>(<S'hg'>, <S'-R'>, <Dpath>,\n                          <S'parent'>, <S'--template={node|short}'>)\n        <C# Look for the default hg path.  If SRVSRV_ROOT is set, we>\n<C>        <C# don't bother asking hg.>\n<C>        <Ahg_root> = <Dos>.<Denviron>.<Dget>(<S\"SRCSRV_ROOT\">)\n        <Vif ><Ahg_root>:\n            <Droot> = <Ahg_root>\n        <Velse:>\n            <Droot> = <Aread_output>(<S'hg'>, <S'-R'>, <Dpath>,\n                               <S'showconfig'>, <S'paths.default'>)\n            <Vif ><Vnot ><Droot>:\n                <Dprint> &gt;&gt; <Dsys>.<Dstderr>, <S\"Failed to get HG Repo for %s\"> % <Dpath>\n        <Acleanroot> = <VNone\n>        <Vif ><Droot>:\n            <Dmatch> = <ArootRegex>.<Dmatch>(<Droot>)\n            <Vif ><Dmatch>:\n                <Acleanroot> = <Dmatch>.<Dgroup>(1)\n                <Vif ><Acleanroot>.<Aendswith>(<S'/'>):\n                    <Acleanroot> = <Acleanroot>[:-1]\n        <Vif ><Acleanroot> <Vis ><VNone:>\n            <Dprint> &gt;&gt; <Dsys>.<Dstderr>, <Atextwrap>.<Ddedent>(<S\"\"\"\\\n                Could not determine repo info for %s.  This is either not a clone of the web-based\n                repository, or you have not specified SRCSRV_ROOT, or the clone is corrupt.\"\"\">) % <Dpath>\n            <Dsys>.<Dexit>(1)\n        <Dself>.<Drev> = <Drev>\n        <Dself>.<Droot> = <Droot>\n        <Dself>.<Acleanroot> = <Acleanroot>\n\n    <Vdef ><DGetFileInfo>(<Dself>, <Dfile>):\n        <Vreturn ><AHGFileInfo>(<Dfile>, <Dself>)\n\n<Vclass ><AHGFileInfo>(<AVCSFileInfo>):\n    <Vdef ><D__init__>(<Dself>, <Dfile>, <Drepo>):\n        <AVCSFileInfo>.<D__init__>(<Dself>, <Dfile>)\n        <Dself>.<Drepo> = <Drepo>\n        <Dself>.<Dfile> = <Dos>.<Dpath>.<Drelpath>(<Dfile>, <Drepo>.<Dpath>)\n\n    <Vdef ><DGetRoot>(<Dself>):\n        <Vreturn ><Dself>.<Drepo>.<Droot>\n\n    <Vdef ><AGetCleanRoot>(<Dself>):\n        <Vreturn ><Dself>.<Drepo>.<Acleanroot>\n\n    <Vdef ><AGetRevision>(<Dself>):\n        <Vreturn ><Dself>.<Drepo>.<Drev>\n\n    <Vdef ><DGetFilename>(<Dself>):\n        <Vif ><Dself>.<Drevision> <Vand ><Dself>.<Aclean_root>:\n            <Vreturn ><S\"hg:%s:%s:%s\"> % (<Dself>.<Aclean_root>, <Dself>.<Dfile>, <Dself>.<Drevision>)\n        <Vreturn ><Dself>.<Dfile>\n\n<Vclass ><AGitRepoInfo>:\n    <S\"\"\"\n    Info about a local git repository. Does not currently\n    support discovering info about a git clone, the info must be\n    provided out-of-band.\n    \"\"\">\n    <Vdef ><D__init__>(<Dself>, <Dpath>, <Drev>, <Droot>):\n        <Dself>.<Dpath> = <Dpath>\n        <Acleanroot> = <VNone\n>        <Vif ><Droot>:\n            <Dmatch> = <ArootRegex>.<Dmatch>(<Droot>)\n            <Vif ><Dmatch>:\n                <Acleanroot> = <Dmatch>.<Dgroup>(1)\n                <Vif ><Acleanroot>.<Aendswith>(<S'/'>):\n                    <Acleanroot> = <Acleanroot>[:-1]\n        <Vif ><Acleanroot> <Vis ><VNone:>\n            <Dprint> &gt;&gt; <Dsys>.<Dstderr>, <Atextwrap>.<Ddedent>(<S\"\"\"\\\n                Could not determine repo info for %s (%s).  This is either not a clone of a web-based\n                repository, or you have not specified SRCSRV_ROOT, or the clone is corrupt.\"\"\">) % (<Dpath>, <Droot>)\n            <Dsys>.<Dexit>(1)\n        <Dself>.<Drev> = <Drev>\n        <Dself>.<Acleanroot> = <Acleanroot>\n\n    <Vdef ><DGetFileInfo>(<Dself>, <Dfile>):\n        <Vreturn ><AGitFileInfo>(<Dfile>, <Dself>)\n\n<Vclass ><AGitFileInfo>(<AVCSFileInfo>):\n    <Vdef ><D__init__>(<Dself>, <Dfile>, <Drepo>):\n        <AVCSFileInfo>.<D__init__>(<Dself>, <Dfile>)\n        <Dself>.<Drepo> = <Drepo>\n        <Dself>.<Dfile> = <Dos>.<Dpath>.<Drelpath>(<Dfile>, <Drepo>.<Dpath>)\n\n    <Vdef ><DGetRoot>(<Dself>):\n        <Vreturn ><Dself>.<Drepo>.<Dpath>\n\n    <Vdef ><AGetCleanRoot>(<Dself>):\n        <Vreturn ><Dself>.<Drepo>.<Acleanroot>\n\n    <Vdef ><AGetRevision>(<Dself>):\n        <Vreturn ><Dself>.<Drepo>.<Drev>\n\n    <Vdef ><DGetFilename>(<Dself>):\n        <Vif ><Dself>.<Drevision> <Vand ><Dself>.<Aclean_root>:\n            <Vreturn ><S\"git:%s:%s:%s\"> % (<Dself>.<Aclean_root>, <Dself>.<Dfile>, <Dself>.<Drevision>)\n        <Vreturn ><Dself>.<Dfile>\n\n<C# Utility functions>\n<C>\n<C# A cache of files for which VCS info has already been determined. Used to>\n<C><C# prevent extra filesystem activity or process launching.>\n<C><AvcsFileInfoCache> = {}\n\n<Vdef ><AIsInDir>(<Dfile>, <Ddir>):\n    <C# the lower() is to handle win32+vc8, where>\n<C>    <C# the source filenames come out all lowercase,>\n<C>    <C# but the srcdir can be mixed case>\n<C>    <Vreturn ><Dos>.<Dpath>.<Dabspath>(<Dfile>).<Dlower>().<Astartswith>(<Dos>.<Dpath>.<Dabspath>(<Ddir>).<Dlower>())\n\n<Vdef ><AGetVCSFilenameFromSrcdir>(<Dfile>, <Dsrcdir>):\n    <Vif ><Dsrcdir> <Vnot ><Vin ><DDumper>.<AsrcdirRepoInfo>:\n        <C# Not in cache, so find it adnd cache it>\n<C>        <Vif ><Dos>.<Dpath>.<Disdir>(<Dos>.<Dpath>.<Djoin>(<Dsrcdir>, <S'.hg'>)):\n            <DDumper>.<AsrcdirRepoInfo>[<Dsrcdir>] = <AHGRepoInfo>(<Dsrcdir>)\n        <Velse:>\n            <C# Unknown VCS or file is not in a repo.>\n<C>            <Vreturn ><VNone\n>    <Vreturn ><DDumper>.<AsrcdirRepoInfo>[<Dsrcdir>].<DGetFileInfo>(<Dfile>)\n\n<Vdef ><AGetVCSFilename>(<Dfile>, <Asrcdirs>):\n    <S\"\"\"Given a full path to a file, and the top source directory,\n    look for version control information about this file, and return\n    a tuple containing\n    1) a specially formatted filename that contains the VCS type,\n    VCS location, relative filename, and revision number, formatted like:\n    vcs:vcs location:filename:revision\n    For example:\n    cvs:cvs.mozilla.org/cvsroot:mozilla/browser/app/nsBrowserApp.cpp:1.36\n    2) the unmodified root information if it exists\"\"\">\n    (<Dpath>, <Dfilename>) = <Dos>.<Dpath>.<Dsplit>(<Dfile>)\n    <Vif ><Dpath> == <S''> <Vor ><Dfilename> == <S''>:\n        <Vreturn >(<Dfile>, <VNone)>\n\n    <DfileInfo> = <VNone\n>    <Droot> = <S''>\n    <Vif ><Dfile> <Vin ><AvcsFileInfoCache>:\n        <C# Already cached this info, use it.>\n<C>        <DfileInfo> = <AvcsFileInfoCache>[<Dfile>]\n    <Velse:>\n        <Vfor ><Dsrcdir> <Vin ><Asrcdirs>:\n            <Vif ><Vnot ><AIsInDir>(<Dfile>, <Dsrcdir>):\n                <Vcontinue\n>            <DfileInfo> = <AGetVCSFilenameFromSrcdir>(<Dfile>, <Dsrcdir>)\n            <Vif ><DfileInfo>:\n                <AvcsFileInfoCache>[<Dfile>] = <DfileInfo>\n                <Vbreak\n>\n    <Vif ><DfileInfo>:\n        <Dfile> = <DfileInfo>.<Dfilename>\n        <Droot> = <DfileInfo>.<Droot>\n\n    <C# we want forward slashes on win32 paths>\n<C>    <Vreturn >(<Dfile>.<Dreplace>(<S\"\\\\\">, <S\"/\">), <Droot>)\n\n<Vdef ><AGetPlatformSpecificDumper>(**<Akwargs>):\n    <S\"\"\"This function simply returns a instance of a subclass of Dumper\n    that is appropriate for the current platform.\"\"\">\n    <C# Python 2.5 has a bug where platform.system() returns 'Microsoft'.>\n<C>    <C# Remove this when we no longer support Python 2.5.>\n<C>    <Vreturn >{<S'Windows'>: <ADumper_Win32>,\n            <S'Microsoft'>: <ADumper_Win32>,\n            <S'Linux'>: <ADumper_Linux>,\n            <S'Sunos5'>: <ADumper_Solaris>,\n            <S'Darwin'>: <ADumper_Mac>}[<Dplatform>.<Dsystem>()](**<Akwargs>)\n\n<Vdef ><ASourceIndex>(<DfileStream>, <AoutputPath>, <Avcs_root>):\n    <S\"\"\"Takes a list of files, writes info to a data block in a .stream file\"\"\">\n    <C# Creates a .pdb.stream file in the mozilla\\objdir to be used for source indexing>\n<C>    <C# Create the srcsrv data block that indexes the pdb file>\n<C>    <Dresult> = <VTrue\n>    <ApdbStreamFile> = <Dopen>(<AoutputPath>, <S\"w\">)\n    <ApdbStreamFile>.<Dwrite>(<S'''SRCSRV: ini ------------------------------------------------\\r\\nVERSION=2\\r\\nINDEXVERSION=2\\r\\nVERCTRL=http\\r\\nSRCSRV: variables ------------------------------------------\\r\\nHGSERVER='''>)\n    <ApdbStreamFile>.<Dwrite>(<Avcs_root>)\n    <ApdbStreamFile>.<Dwrite>(<S'''\\r\\nSRCSRVVERCTRL=http\\r\\nHTTP_EXTRACT_TARGET=%hgserver%/raw-file/%var3%/%var2%\\r\\nSRCSRVTRG=%http_extract_target%\\r\\nSRCSRV: source files ---------------------------------------\\r\\n'''>)\n    <ApdbStreamFile>.<Dwrite>(<DfileStream>) <C# can't do string interpolation because the source server also uses this and so there are % in the above>\n<C>    <ApdbStreamFile>.<Dwrite>(<S\"SRCSRV: end ------------------------------------------------\\r\\n\\n\">)\n    <ApdbStreamFile>.<Dclose>()\n    <Vreturn ><Dresult>\n\n<Vdef ><AWorkerInitializer>(<Dcls>, <Dlock>, <AsrcdirRepoInfo>):\n    <S\"\"\"Windows worker processes won't have run GlobalInit, and due to a lack of fork(),\n    won't inherit the class variables from the parent. They only need a few variables,\n    so we run an initializer to set them. Redundant but harmless on other platforms.\"\"\">\n    <Dcls>.<Dlock> = <Dlock>\n    <Dcls>.<AsrcdirRepoInfo> = <AsrcdirRepoInfo>\n\n<Vdef ><AStartProcessFilesWork>(<Ddumper>, <Dfiles>, <Aarch_num>, <Darch>, <Avcs_root>, <Dafter>, <Aafter_arg>):\n    <S\"\"\"multiprocessing can't handle methods as Process targets, so we define\n    a simple wrapper function around the work method.\"\"\">\n    <Vreturn ><Ddumper>.<AProcessFilesWork>(<Dfiles>, <Aarch_num>, <Darch>, <Avcs_root>, <Dafter>, <Aafter_arg>)\n\n<Vclass ><DDumper>:\n    <S\"\"\"This class can dump symbols from a file with debug info, and\n    store the output in a directory structure that is valid for use as\n    a Breakpad symbol server.  Requires a path to a dump_syms binary--\n    |dump_syms| and a directory to store symbols in--|symbol_path|.\n    Optionally takes a list of processor architectures to process from\n    each debug file--|archs|, the full path to the top source\n    directory--|srcdir|, for generating relative source file names,\n    and an option to copy debug info files alongside the dumped\n    symbol files--|copy_debug|, mostly useful for creating a\n    Microsoft Symbol Server from the resulting output.\n\n    You don't want to use this directly if you intend to call\n    ProcessDir.  Instead, call GetPlatformSpecificDumper to\n    get an instance of a subclass.\n \n    Processing is performed asynchronously via worker processes; in\n    order to wait for processing to finish and cleanup correctly, you\n    must call Finish after all Process/ProcessDir calls have been made.\n    You must also call Dumper.GlobalInit before creating or using any\n    instances.\"\"\">\n    <Vdef ><D__init__>(<Dself>, <Adump_syms>, <Asymbol_path>,\n                 <Aarchs>=");
</script><script>addCode("<VNone,>\n                 <Asrcdirs>=[],\n                 <Acopy_debug>=<VFalse,>\n                 <Avcsinfo>=<VFalse,>\n                 <Asrcsrv>=<VFalse,>\n                 <Dexclude>=[],\n                 <Arepo_manifest>=<VNone)>:\n        <C# popen likes absolute paths, at least on windows>\n<C>        <Dself>.<Adump_syms> = <Dos>.<Dpath>.<Dabspath>(<Adump_syms>)\n        <Dself>.<Asymbol_path> = <Asymbol_path>\n        <Vif ><Aarchs> <Vis ><VNone:>\n            <C# makes the loop logic simpler>\n<C>            <Dself>.<Aarchs> = [<S''>]\n        <Velse:>\n            <Dself>.<Aarchs> = [<S'-a %s'> % <Da> <Vfor ><Da> <Vin ><Aarchs>.<Dsplit>()]\n        <Dself>.<Asrcdirs> = [<Dos>.<Dpath>.<Anormpath>(<Da>) <Vfor ><Da> <Vin ><Asrcdirs>]\n        <Dself>.<Acopy_debug> = <Acopy_debug>\n        <Dself>.<Avcsinfo> = <Avcsinfo>\n        <Dself>.<Asrcsrv> = <Asrcsrv>\n        <Dself>.<Dexclude> = <Dexclude>[:]\n        <Vif ><Arepo_manifest>:\n            <Dself>.<Aparse_repo_manifest>(<Arepo_manifest>)\n\n        <C# book-keeping to keep track of our jobs and the cleanup work per file tuple>\n<C>        <Dself>.<Afiles_record> = {}\n        <Dself>.<Ajobs_record> = <Dcollections>.<Adefaultdict>(<Dint>)\n\n    @<Aclassmethod>\n    <Vdef ><DGlobalInit>(<Dcls>, <Dmodule>=<Amultiprocessing>):\n        <S\"\"\"Initialize the class globals for the multiprocessing setup; must\n        be called before any Dumper instances are created and used. Test cases\n        may pass in a different module to supply Manager and Pool objects,\n        usually multiprocessing.dummy.\"\"\">\n        <Anum_cpus> = <Dmodule>.<Dcpu_count>()\n        <Vif ><Anum_cpus> <Vis ><VNone:>\n            <C# assume a dual core machine if we can't find out for some reason>\n<C>            <C# probably better on single core anyway due to I/O constraints>\n<C>            <Anum_cpus> = 2\n\n        <C# have to create any locks etc before the pool>\n<C>        <Dcls>.<Dmanager> = <Dmodule>.<DManager>()\n        <Dcls>.<Ajobs_condition> = <DDumper>.<Dmanager>.<DCondition>()\n        <Dcls>.<Dlock> = <DDumper>.<Dmanager>.<ARLock>()\n        <Dcls>.<AsrcdirRepoInfo> = <DDumper>.<Dmanager>.<Ddict>()\n        <Dcls>.<Dpool> = <Dmodule>.<DPool>(<Anum_cpus>, <AWorkerInitializer>,\n                               (<Dcls>, <Dcls>.<Dlock>, <Dcls>.<AsrcdirRepoInfo>))\n\n    <Vdef ><AJobStarted>(<Dself>, <Afile_key>):\n        <S\"\"\"Increments the number of submitted jobs for the specified key file,\n        defined as the original file we processed; note that a single key file\n        can generate up to 1 + len(self.archs) jobs in the Mac case.\"\"\">\n        <Awith> <DDumper>.<Ajobs_condition>:\n            <Dself>.<Ajobs_record>[<Afile_key>] += 1\n            <DDumper>.<Ajobs_condition>.<Anotify_all>()\n\n    <Vdef ><AJobFinished>(<Dself>, <Afile_key>):\n        <S\"\"\"Decrements the number of submitted jobs for the specified key file,\n        defined as the original file we processed; once the count is back to 0,\n        remove the entry from our record.\"\"\">\n        <Awith> <DDumper>.<Ajobs_condition>:\n            <Dself>.<Ajobs_record>[<Afile_key>] -= 1\n\n            <Vif ><Dself>.<Ajobs_record>[<Afile_key>] == 0:\n                <Vdel ><Dself>.<Ajobs_record>[<Afile_key>]\n\n            <DDumper>.<Ajobs_condition>.<Anotify_all>()\n\n    <Vdef ><Doutput>(<Dself>, <Ddest>, <Aoutput_str>):\n        <S\"\"\"Writes |output_str| to |dest|, holding |lock|;\n        terminates with a newline.\"\"\">\n        <Awith> <DDumper>.<Dlock>:\n            <Ddest>.<Dwrite>(<Aoutput_str> + <S\"\\n\">)\n            <Ddest>.<Dflush>()\n\n    <Vdef ><Aoutput_pid>(<Dself>, <Ddest>, <Aoutput_str>):\n        <S\"\"\"Debugging output; prepends the pid to the string.\"\"\">\n        <Dself>.<Doutput>(<Ddest>, <S\"%d: %s\"> % (<Dos>.<Dgetpid>(), <Aoutput_str>))\n\n    <Vdef ><Aparse_repo_manifest>(<Dself>, <Arepo_manifest>):\n        <S\"\"\"\n        Parse an XML manifest of repository info as produced\n        by the `repo manifest -r` command.\n        \"\"\">\n        <Ddoc> = <Dparse>(<Arepo_manifest>)\n        <Vif ><Ddoc>.<DfirstChild>.<DtagName> != <S\"manifest\">:\n            <Vreturn\n>        <C# First, get remotes.>\n<C>        <Vdef ><Aensure_slash>(<Du>):\n            <Vif ><Vnot ><Du>.<Aendswith>(<S\"/\">):\n                <Vreturn ><Du> + <S\"/\">\n            <Vreturn ><Du>\n        <Aremotes> = <Ddict>([(<Dr>.<DgetAttribute>(<S\"name\">), <Aensure_slash>(<Dr>.<DgetAttribute>(<S\"fetch\">))) <Vfor ><Dr> <Vin ><Ddoc>.<DgetElementsByTagName>(<S\"remote\">)])\n        <C# And default remote.>\n<C>        <Adefault_remote> = <VNone\n>        <Vif ><Ddoc>.<DgetElementsByTagName>(<S\"default\">):\n            <Adefault_remote> = <Ddoc>.<DgetElementsByTagName>(<S\"default\">)[0].<DgetAttribute>(<S\"remote\">)\n        <C# Now get projects. Assume they're relative to repo_manifest.>\n<C>        <Abase_dir> = <Dos>.<Dpath>.<Dabspath>(<Dos>.<Dpath>.<Ddirname>(<Arepo_manifest>))\n        <Vfor ><Aproj> <Vin ><Ddoc>.<DgetElementsByTagName>(<S\"project\">):\n            <C# name is the repository URL relative to the remote path.>\n<C>            <Dname> = <Aproj>.<DgetAttribute>(<S\"name\">)\n            <C# path is the path on-disk, relative to the manifest file.>\n<C>            <Dpath> = <Aproj>.<DgetAttribute>(<S\"path\">)\n            <C# revision is the changeset ID.>\n<C>            <Drev> = <Aproj>.<DgetAttribute>(<S\"revision\">)\n            <C# remote is the base URL to use.>\n<C>            <Dremote> = <Aproj>.<DgetAttribute>(<S\"remote\">)\n            <C# remote defaults to the &lt;default remote&gt;.>\n<C>            <Vif ><Vnot ><Dremote>:\n                <Dremote> = <Adefault_remote>\n            <C# path defaults to name.>\n<C>            <Vif ><Vnot ><Dpath>:\n                <Dpath> = <Dname>\n            <Vif ><Vnot >(<Dname> <Vand ><Dpath> <Vand ><Drev> <Vand ><Dremote>):\n                <Dprint> <S\"Skipping project %s\"> % <Aproj>.<Atoxml>()\n                <Vcontinue\n>            <Dremote> = <Aremotes>[<Dremote>]\n            <C# Turn git URLs into http URLs so that urljoin works.>\n<C>            <Vif ><Dremote>.<Astartswith>(<S\"git:\">):\n                <Dremote> = <S\"http\"> + <Dremote>[3:]\n            <C# Add this project to srcdirs.>\n<C>            <Dsrcdir> = <Dos>.<Dpath>.<Djoin>(<Abase_dir>, <Dpath>)\n            <Dself>.<Asrcdirs>.<Dappend>(<Dsrcdir>)\n            <C# And cache its VCS file info. Currently all repos mentioned>\n<C>            <C# in a repo manifest are assumed to be git.>\n<C>            <Droot> = <Aurlparse>.<Aurljoin>(<Dremote>, <Dname>)\n            <DDumper>.<AsrcdirRepoInfo>[<Dsrcdir>] = <AGitRepoInfo>(<Dsrcdir>, <Drev>, <Droot>)\n\n    <C# subclasses override this>\n<C>    <Vdef ><DShouldProcess>(<Dself>, <Dfile>):\n        <Vreturn ><Vnot ><Dany>(<Afnmatch>.<Afnmatch>(<Dos>.<Dpath>.<Dbasename>(<Dfile>), <Dexclude>) <Vfor ><Dexclude> <Vin ><Dself>.<Dexclude>)\n\n    <C# and can override this>\n<C>    <Vdef ><AShouldSkipDir>(<Dself>, <Ddir>):\n        <Vreturn ><VFalse\n>\n    <Vdef ><ARunFileCommand>(<Dself>, <Dfile>):\n        <S\"\"\"Utility function, returns the output of file(1)\"\"\">\n        <Vtry:>\n            <C# we use -L to read the targets of symlinks,>\n<C>            <C# and -b to print just the content, not the filename>\n<C>            <Vreturn ><Dos>.<Dpopen>(<S\"file -Lb \"> + <Dfile>).<Dread>()\n        <Vexcept:>\n            <Vreturn ><S\"\">\n\n    <C# This is a no-op except on Win32>\n<C>    <Vdef ><AFixFilenameCase>(<Dself>, <Dfile>):\n        <Vreturn ><Dfile>\n\n    <C# This is a no-op except on Win32>\n<C>    <Vdef ><ASourceServerIndexing>(<Dself>, <Ddebug_file>, <Dguid>, <AsourceFileStream>, <Avcs_root>):\n        <Vreturn ><S\"\">\n\n    <C# subclasses override this if they want to support this>\n<C>    <Vdef ><ACopyDebug>(<Dself>, <Dfile>, <Ddebug_file>, <Dguid>):\n        <Vpass\n>\n    <Vdef ><DFinish>(<Dself>, <Astop_pool>=<VTrue)>:\n        <S\"\"\"Wait for the expected number of jobs to be submitted, and then\n        wait for the pool to finish processing them. By default, will close\n        and clear the pool, but for testcases that need multiple runs, pass\n        stop_pool = False.\"\"\">\n        <Awith> <DDumper>.<Ajobs_condition>:\n            <Vwhile ><Dlen>(<Dself>.<Ajobs_record>) != 0:\n                <DDumper>.<Ajobs_condition>.<Dwait>()\n        <Vif ><Astop_pool>:\n            <DDumper>.<Dpool>.<Dclose>()\n            <DDumper>.<Dpool>.<Djoin>()\n\n    <Vdef ><DProcess>(<Dself>, <Afile_or_dir>):\n        <S\"\"\"Process a file or all the (valid) files in a directory; processing is performed\n        asynchronously, and Finish must be called to wait for it complete and cleanup.\"\"\">\n        <Vif ><Dos>.<Dpath>.<Disdir>(<Afile_or_dir>) <Vand ><Vnot ><Dself>.<AShouldSkipDir>(<Afile_or_dir>):\n            <Dself>.<AProcessDir>(<Afile_or_dir>)\n        <Delif> <Dos>.<Dpath>.<Disfile>(<Afile_or_dir>):\n            <Dself>.<AProcessFiles>((<Afile_or_dir>,))\n\n    <Vdef ><AProcessDir>(<Dself>, <Ddir>):\n        <S\"\"\"Process all the valid files in this directory.  Valid files\n        are determined by calling ShouldProcess; processing is performed\n        asynchronously, and Finish must be called to wait for it complete and cleanup.\"\"\">\n        <Vfor ><Droot>, <Ddirs>, <Dfiles> <Vin ><Dos>.<Dwalk>(<Ddir>):\n            <Vfor ><Dd> <Vin ><Ddirs>[:]:\n                <Vif ><Dself>.<AShouldSkipDir>(<Dd>):\n                    <Ddirs>.<Dremove>(<Dd>)\n            <Vfor ><Df> <Vin ><Dfiles>:\n                <Dfullpath> = <Dos>.<Dpath>.<Djoin>(<Droot>, <Df>)\n                <Vif ><Dself>.<DShouldProcess>(<Dfullpath>):\n                    <Dself>.<AProcessFiles>((<Dfullpath>,))\n\n    <Vdef ><ASubmitJob>(<Dself>, <Afile_key>, <Dfunc>, <Dargs>, <Dcallback>):\n        <S\"\"\"Submits a job to the pool of workers; increments the number of submitted jobs.\"\"\">\n        <Dself>.<AJobStarted>(<Afile_key>)\n        <Dres> = <DDumper>.<Dpool>.<Aapply_async>(<Dfunc>, <Dargs>=<Dargs>, <Dcallback>=<Dcallback>)\n\n    <Vdef ><AProcessFilesFinished>(<Dself>, <Dres>):\n        <S\"\"\"Callback from multiprocesing when ProcessFilesWork finishes;\n        run the cleanup work, if any\"\"\">\n        <Dself>.<AJobFinished>(<Dres>[<S'files'>][-1])\n        <C# only run the cleanup function once per tuple of files>\n<C>        <Dself>.<Afiles_record>[<Dres>[<S'files'>]] += 1\n        <Vif ><Dself>.<Afiles_record>[<Dres>[<S'files'>]] == <Dlen>(<Dself>.<Aarchs>):\n            <Vdel ><Dself>.<Afiles_record>[<Dres>[<S'files'>]]\n            <Vif ><Dres>[<S'after'>]:\n                <Dres>[<S'after'>](<Dres>[<S'status'>], <Dres>[<S'after_arg'>])\n\n    <Vdef ><AProcessFiles>(<Dself>, <Dfiles>, <Dafter>=<VNone,> <Aafter_arg>=<VNone)>:\n        <S\"\"\"Dump symbols from these files into a symbol file, stored\n        in the proper directory structure in  |symbol_path|; processing is performed\n        asynchronously, and Finish must be called to wait for it complete and cleanup.\n        All files after the first are fallbacks in case the first file does not process\n        successfully; if it does, no other files will be touched.\"\"\">\n        <Dself>.<Aoutput_pid>(<Dsys>.<Dstderr>, <S\"Submitting jobs for files: %s\"> % <Dstr>(<Dfiles>))\n\n        <C# tries to get the vcs root from the .mozconfig first - if it's not set>\n<C>        <C# the tinderbox vcs path will be assigned further down>\n<C>        <Avcs_root> = <Dos>.<Denviron>.<Dget>(<S\"SRCSRV_ROOT\">)\n        <Vfor ><Aarch_num>, <Darch> <Vin ><Denumerate>(<Dself>.<Aarchs>):\n            <Dself>.<Afiles_record>[<Dfiles>] = 0 <C# record that we submitted jobs for this tuple of files>\n<C>            <Dself>.<ASubmitJob>(<Dfiles>[-1], <AStartProcessFilesWork>, <Dargs>=(<Dself>, <Dfiles>, <Aarch_num>, <Darch>, <Avcs_root>, <Dafter>, <Aafter_arg>), <Dcallback>=<Dself>.<AProcessFilesFinished>)\n\n    <Vdef ><AProcessFilesWork>(<Dself>, <Dfiles>, <Aarch_num>, <Darch>, <Avcs_root>, <Dafter>, <Aafter_arg>):\n        <Dself>.<Aoutput_pid>(<Dsys>.<Dstderr>, <S\"Worker processing files: %s\"> % (<Dfiles>,))\n\n        <C# our result is a status, a cleanup function, an argument to that function, and the tuple of files we were called on>\n<C>        <Dresult> = { <S'status'> : <VFalse,> <S'after'> : <Dafter>, <S'after_arg'> : <Aafter_arg>, <S'files'> : <Dfiles> }\n\n        <AsourceFileStream> = <S''>\n        <Vfor ><Dfile> <Vin ><Dfiles>:\n            <C# files is a tuple of files, containing fallbacks in case the first file doesn't process successfully>\n<C>            <Vtry:>\n                <Dproc> = <Dsubprocess>.<APopen>([<Dself>.<Adump_syms>] + <Darch>.<Dsplit>() + [<Dfile>],\n                                        <Dstdout>=<Dsubprocess>.<APIPE>)\n                <Amodule_line> = <Dproc>.<Dstdout>.<Dnext>()\n                <Vif ><Amodule_line>.<Astartswith>(<S\"MODULE\">):\n                    <C# MODULE os cpu guid debug_file>\n<C>                    (<Dguid>, <Ddebug_file>) = (<Amodule_line>.<Dsplit>())[3:5]\n                    <C# strip off .pdb extensions, and append .sym>\n<C>                    <Asym_file> = <Dre>.<Dsub>(<S\"\\.pdb$\">, <S\"\">, <Ddebug_file>) + <S\".sym\">\n                    <C# we do want forward slashes here>\n<C>                    <Arel_path> = <Dos>.<Dpath>.<Djoin>(<Ddebug_file>,\n                                            <Dguid>,\n                                            <Asym_file>).<Dreplace>(<S\"\\\\\">, <S\"/\">)\n                    <Dfull_path> = <Dos>.<Dpath>.<Anormpath>(<Dos>.<Dpath>.<Djoin>(<Dself>.<Asymbol_path>,\n                                                              <Arel_path>))\n                    <Vtry:>\n                        <Dos>.<Amakedirs>(<Dos>.<Dpath>.<Ddirname>(<Dfull_path>))\n                    <Vexcept ><DOSError>: <C# already exists>\n<C>                        <Vpass\n>                    <Df> = <Dopen>(<Dfull_path>, <S\"w\">)\n                    <Df>.<Dwrite>(<Amodule_line>)\n                    <C# now process the rest of the output>\n<C>                    <Vfor ><Dline> <Vin ><Dproc>.<Dstdout>:\n                        <Vif ><Dline>.<Astartswith>(<S\"FILE\">):\n                            <C# FILE index filename>\n<C>                            (<Dx>, <Dindex>, <Dfilename>) = <Dline>.<Drstrip>().<Dsplit>(<VNone,> 2)\n                            <Vif ><Dsys>.<Dplatform> == <S\"sunos5\">:\n                                <Vfor ><Dsrcdir> <Vin ><Dself>.<Asrcdirs>:\n                                    <Dstart> = <Dfilename>.<Dfind>(<Dself>.<Dsrcdir>)\n                                    <Vif ><Dstart> != -1:\n                                        <Dfilename> = <Dfilename>[<Dstart>:]\n                                        <Vbreak\n>                            <Dfilename> = <Dself>.<AFixFilenameCase>(<Dfilename>)\n                            <Asourcepath> = <Dfilename>\n                            <Vif ><Dself>.<Avcsinfo>:\n                                (<Dfilename>, <Arootname>) = <AGetVCSFilename>(<Dfilename>, <Dself>.<Asrcdirs>)\n                                <C# sets vcs_root in case the loop through files were to end on an empty rootname>\n<C>                                <Vif ><Avcs_root> <Vis ><VNone:>\n                                  <Vif ><Arootname>:\n                                     <Avcs_root> = <Arootname>\n                            <C# gather up files with hg for indexing   >\n<C>                            <Vif ><Dfilename>.<Astartswith>(<S\"hg\">):\n                                (<Dver>, <Acheckout>, <Dsource_file>, <Drevision>) = <Dfilename>.<Dsplit>(<S\":\">, 3)\n                                <AsourceFileStream> += <Asourcepath> + <S\"*\"> + <Dsource_file> + <S'*'> + <Drevision> + <S\"\\r\\n\">\n                            <Df>.<Dwrite>(<S\"FILE %s %s\\n\"> % (<Dindex>, <Dfilename>))\n                        <Velse:>\n                            <C# pass through all other lines unchanged>\n<C>                            <Df>.<Dwrite>(<Dline>)\n                            <C# we want to return true only if at least one line is not a MODULE or FILE line>\n<C>                            <Dresult>[<S'status'>] = <VTrue\n>                    <Df>.<Dclose>()\n                    <Dproc>.<Dwait>()\n                    ");
</script><script>addCode("<C# we output relative paths so callers can get a list of what>\n<C>                    <C# was generated>\n<C>                    <Dself>.<Doutput>(<Dsys>.<Dstdout>, <Arel_path>)\n                    <Vif ><Dself>.<Asrcsrv> <Vand ><Avcs_root>:\n                        <C# add source server indexing to the pdb file>\n<C>                        <Dself>.<ASourceServerIndexing>(<Dfile>, <Dguid>, <AsourceFileStream>, <Avcs_root>)\n                    <C# only copy debug the first time if we have multiple architectures>\n<C>                    <Vif ><Dself>.<Acopy_debug> <Vand ><Aarch_num> == 0:\n                        <Dself>.<ACopyDebug>(<Dfile>, <Ddebug_file>, <Dguid>)\n            <Vexcept ><AStopIteration>:\n                <Vpass\n>            <Vexcept ><De>:\n                <Dself>.<Doutput>(<Dsys>.<Dstderr>, <S\"Unexpected error: %s\"> % (<Dstr>(<De>),))\n                <Vraise\n>            <Vif ><Dresult>[<S'status'>]:\n                <C# we only need 1 file to work>\n<C>                <Vbreak\n>        <Vreturn ><Dresult>\n\n<C# Platform-specific subclasses.  For the most part, these just have>\n<C><C# logic to determine what files to extract symbols from.>\n<C>\n<Vclass ><ADumper_Win32>(<DDumper>):\n    <AfixedFilenameCaseCache> = {}\n\n    <Vdef ><DShouldProcess>(<Dself>, <Dfile>):\n        <S\"\"\"This function will allow processing of pdb files that have dll\n        or exe files with the same base name next to them.\"\"\">\n        <Vif ><Vnot ><DDumper>.<DShouldProcess>(<Dself>, <Dfile>):\n            <Vreturn ><VFalse\n>        <Vif ><Dfile>.<Aendswith>(<S\".pdb\">):\n            (<Dpath>,<Dext>) = <Dos>.<Dpath>.<Asplitext>(<Dfile>)\n            <Vif ><Dos>.<Dpath>.<Disfile>(<Dpath> + <S\".exe\">) <Vor ><Dos>.<Dpath>.<Disfile>(<Dpath> + <S\".dll\">):\n                <Vreturn ><VTrue\n>        <Vreturn ><VFalse\n>\n    <Vdef ><AFixFilenameCase>(<Dself>, <Dfile>):\n        <S\"\"\"Recent versions of Visual C++ put filenames into\n        PDB files as all lowercase.  If the file exists\n        on the local filesystem, fix it.\"\"\">\n\n        <C# Use a cached version if we have one.>\n<C>        <Vif ><Dfile> <Vin ><Dself>.<AfixedFilenameCaseCache>:\n            <Vreturn ><Dself>.<AfixedFilenameCaseCache>[<Dfile>]\n\n        <Dresult> = <Dfile>\n\n        (<Dpath>, <Dfilename>) = <Dos>.<Dpath>.<Dsplit>(<Dfile>)\n        <Vif ><Dos>.<Dpath>.<Disdir>(<Dpath>):\n            <Alc_filename> = <Dfilename>.<Dlower>()\n            <Vfor ><Df> <Vin ><Dos>.<Alistdir>(<Dpath>):\n                <Vif ><Df>.<Dlower>() == <Alc_filename>:\n                    <Dresult> = <Dos>.<Dpath>.<Djoin>(<Dpath>, <Df>)\n                    <Vbreak\n>\n        <C# Cache the corrected version to avoid future filesystem hits.>\n<C>        <Dself>.<AfixedFilenameCaseCache>[<Dfile>] = <Dresult>\n        <Vreturn ><Dresult>\n\n    <Vdef ><ACopyDebug>(<Dself>, <Dfile>, <Ddebug_file>, <Dguid>):\n        <Arel_path> = <Dos>.<Dpath>.<Djoin>(<Ddebug_file>,\n                                <Dguid>,\n                                <Ddebug_file>).<Dreplace>(<S\"\\\\\">, <S\"/\">)\n        <Dfull_path> = <Dos>.<Dpath>.<Anormpath>(<Dos>.<Dpath>.<Djoin>(<Dself>.<Asymbol_path>,\n                                                  <Arel_path>))\n        <Ashutil>.<Dcopyfile>(<Dfile>, <Dfull_path>)\n        <C# try compressing it>\n<C>        <Acompressed_file> = <Dos>.<Dpath>.<Asplitext>(<Dfull_path>)[0] + <S\".pd_\">\n        <C# ignore makecab's output>\n<C>        <Dsuccess> = <Dsubprocess>.<Dcall>([<S\"makecab.exe\">, <S\"/D\">, <S\"CompressionType=LZX\">, <S\"/D\">,\n                                   <S\"CompressionMemory=21\">,\n                                   <Dfull_path>, <Acompressed_file>],\n                                  <Dstdout>=<Dopen>(<S\"NUL:\">,<S\"w\">), <Dstderr>=<Dsubprocess>.<ASTDOUT>)\n        <Vif ><Dsuccess> == 0 <Vand ><Dos>.<Dpath>.<Dexists>(<Acompressed_file>):\n            <Dos>.<Dunlink>(<Dfull_path>)\n            <Dself>.<Doutput>(<Dsys>.<Dstdout>, <Dos>.<Dpath>.<Asplitext>(<Arel_path>)[0] + <S\".pd_\">)\n        <Velse:>\n            <Dself>.<Doutput>(<Dsys>.<Dstdout>, <Arel_path>)\n        \n    <Vdef ><ASourceServerIndexing>(<Dself>, <Ddebug_file>, <Dguid>, <AsourceFileStream>, <Avcs_root>):\n        <C# Creates a .pdb.stream file in the mozilla\\objdir to be used for source indexing>\n<C>        <Ddebug_file> = <Dos>.<Dpath>.<Dabspath>(<Ddebug_file>)\n        <AstreamFilename> = <Ddebug_file> + <S\".stream\">\n        <Astream_output_path> = <Dos>.<Dpath>.<Dabspath>(<AstreamFilename>)\n        <C# Call SourceIndex to create the .stream file>\n<C>        <Dresult> = <ASourceIndex>(<AsourceFileStream>, <Astream_output_path>, <Avcs_root>)\n        <Vif ><Dself>.<Acopy_debug>:\n            <Apdbstr_path> = <Dos>.<Denviron>.<Dget>(<S\"PDBSTR_PATH\">)\n            <Apdbstr> = <Dos>.<Dpath>.<Anormpath>(<Apdbstr_path>)\n            <Dsubprocess>.<Dcall>([<Apdbstr>, <S\"-w\">, <S\"-p:\"> + <Dos>.<Dpath>.<Dbasename>(<Ddebug_file>),\n                             <S\"-i:\"> + <Dos>.<Dpath>.<Dbasename>(<AstreamFilename>), <S\"-s:srcsrv\">],\n                            <Dcwd>=<Dos>.<Dpath>.<Ddirname>(<Astream_output_path>))\n            <C# clean up all the .stream files when done>\n<C>            <Dos>.<Dremove>(<Astream_output_path>)\n        <Vreturn ><Dresult>\n\n<Vclass ><ADumper_Linux>(<DDumper>):\n    <Aobjcopy> = <Dos>.<Denviron>[<S'OBJCOPY'>] <Vif ><S'OBJCOPY'> <Vin ><Dos>.<Denviron> <Velse ><S'objcopy'>\n    <Vdef ><DShouldProcess>(<Dself>, <Dfile>):\n        <S\"\"\"This function will allow processing of files that are\n        executable, or end with the .so extension, and additionally\n        file(1) reports as being ELF files.  It expects to find the file\n        command in PATH.\"\"\">\n        <Vif ><Vnot ><DDumper>.<DShouldProcess>(<Dself>, <Dfile>):\n            <Vreturn ><VFalse\n>        <Vif ><Dfile>.<Aendswith>(<S\".so\">) <Vor ><Dos>.<Daccess>(<Dfile>, <Dos>.<AX_OK>):\n            <Vreturn ><Dself>.<ARunFileCommand>(<Dfile>).<Astartswith>(<S\"ELF\">)\n        <Vreturn ><VFalse\n>\n    <Vdef ><ACopyDebug>(<Dself>, <Dfile>, <Ddebug_file>, <Dguid>):\n        <C# We want to strip out the debug info, and add a>\n<C>        <C# .gnu_debuglink section to the object, so the debugger can>\n<C>        <C# actually load our debug info later.>\n<C>        <Afile_dbg> = <Dfile> + <S\".dbg\">\n        <Vif ><Dsubprocess>.<Dcall>([<Dself>.<Aobjcopy>, <S'--only-keep-debug'>, <Dfile>, <Afile_dbg>]) == 0 <Vand >\\\n           <Dsubprocess>.<Dcall>([<Dself>.<Aobjcopy>, <S'--add-gnu-debuglink=%s'> % <Afile_dbg>, <Dfile>]) == 0:\n            <Arel_path> = <Dos>.<Dpath>.<Djoin>(<Ddebug_file>,\n                                    <Dguid>,\n                                    <Ddebug_file> + <S\".dbg\">)\n            <Dfull_path> = <Dos>.<Dpath>.<Anormpath>(<Dos>.<Dpath>.<Djoin>(<Dself>.<Asymbol_path>,\n                                                      <Arel_path>))\n            <Ashutil>.<Dmove>(<Afile_dbg>, <Dfull_path>)\n            <C# gzip the shipped debug files>\n<C>            <Dos>.<Dsystem>(<S\"gzip %s\"> % <Dfull_path>)\n            <Dself>.<Doutput>(<Dsys>.<Dstdout>, <Arel_path> + <S\".gz\">)\n        <Velse:>\n            <Vif ><Dos>.<Dpath>.<Disfile>(<Afile_dbg>):\n                <Dos>.<Dunlink>(<Afile_dbg>)\n\n<Vclass ><ADumper_Solaris>(<DDumper>):\n    <Vdef ><ARunFileCommand>(<Dself>, <Dfile>):\n        <S\"\"\"Utility function, returns the output of file(1)\"\"\">\n        <Vtry:>\n            <Doutput> = <Dos>.<Dpopen>(<S\"file \"> + <Dfile>).<Dread>()\n            <Vreturn ><Doutput>.<Dsplit>(<S'\\t'>)[1];\n        <Vexcept:>\n            <Vreturn ><S\"\">\n\n    <Vdef ><DShouldProcess>(<Dself>, <Dfile>):\n        <S\"\"\"This function will allow processing of files that are\n        executable, or end with the .so extension, and additionally\n        file(1) reports as being ELF files.  It expects to find the file\n        command in PATH.\"\"\">\n        <Vif ><Vnot ><DDumper>.<DShouldProcess>(<Dself>, <Dfile>):\n            <Vreturn ><VFalse\n>        <Vif ><Dfile>.<Aendswith>(<S\".so\">) <Vor ><Dos>.<Daccess>(<Dfile>, <Dos>.<AX_OK>):\n            <Vreturn ><Dself>.<ARunFileCommand>(<Dfile>).<Astartswith>(<S\"ELF\">)\n        <Vreturn ><VFalse\n>\n<Vdef ><AStartProcessFilesWorkMac>(<Ddumper>, <Dfile>):\n    <S\"\"\"multiprocessing can't handle methods as Process targets, so we define\n    a simple wrapper function around the work method.\"\"\">\n    <Vreturn ><Ddumper>.<AProcessFilesWorkMac>(<Dfile>)\n\n<Vdef ><AAfterMac>(<Dstatus>, <Adsymbundle>):\n    <S\"\"\"Cleanup function to run on Macs after we process the file(s).\"\"\">\n    <C# CopyDebug will already have been run from Dumper.ProcessFiles>\n<C>    <Ashutil>.<Armtree>(<Adsymbundle>)\n\n<Vclass ><ADumper_Mac>(<DDumper>):\n    <Vdef ><DShouldProcess>(<Dself>, <Dfile>):\n        <S\"\"\"This function will allow processing of files that are\n        executable, or end with the .dylib extension, and additionally\n        file(1) reports as being Mach-O files.  It expects to find the file\n        command in PATH.\"\"\">\n        <Vif ><Vnot ><DDumper>.<DShouldProcess>(<Dself>, <Dfile>):\n            <Vreturn ><VFalse\n>        <Vif ><Dfile>.<Aendswith>(<S\".dylib\">) <Vor ><Dos>.<Daccess>(<Dfile>, <Dos>.<AX_OK>):\n            <Vreturn ><Dself>.<ARunFileCommand>(<Dfile>).<Astartswith>(<S\"Mach-O\">)\n        <Vreturn ><VFalse\n>\n    <Vdef ><AShouldSkipDir>(<Dself>, <Ddir>):\n        <S\"\"\"We create .dSYM bundles on the fly, but if someone runs\n        buildsymbols twice, we should skip any bundles we created\n        previously, otherwise we'll recurse into them and try to \n        dump the inner bits again.\"\"\">\n        <Vif ><Ddir>.<Aendswith>(<S\".dSYM\">):\n            <Vreturn ><VTrue\n>        <Vreturn ><VFalse\n>\n    <Vdef ><AProcessFiles>(<Dself>, <Dfiles>, <Dafter>=<VNone,> <Aafter_arg>=<VNone)>:\n        <C# also note, files must be len 1 here, since we're the only ones>\n<C>        <C# that ever add more than one file to the list>\n<C>        <Dself>.<Aoutput_pid>(<Dsys>.<Dstderr>, <S\"Submitting job for Mac pre-processing on file: %s\"> % (<Dfiles>[0]))\n        <Dself>.<ASubmitJob>(<Dfiles>[0], <AStartProcessFilesWorkMac>, <Dargs>=(<Dself>, <Dfiles>[0]), <Dcallback>=<Dself>.<AProcessFilesMacFinished>)\n\n    <Vdef ><AProcessFilesMacFinished>(<Dself>, <Dresult>):\n        <Vif ><Dresult>[<S'status'>]:\n            <C# kick off new jobs per-arch with our new list of files>\n<C>            <DDumper>.<AProcessFiles>(<Dself>, <Dresult>[<S'files'>], <Dafter>=<AAfterMac>, <Aafter_arg>=<Dresult>[<S'files'>][0])\n        <C# only decrement jobs *after* that, since otherwise we'll remove the record for this file>\n<C>        <Dself>.<AJobFinished>(<Dresult>[<S'files'>][-1])\n\n    <Vdef ><AProcessFilesWorkMac>(<Dself>, <Dfile>):\n        <S\"\"\"dump_syms on Mac needs to be run on a dSYM bundle produced\n        by dsymutil(1), so run dsymutil here and pass the bundle name\n        down to the superclass method instead.\"\"\">\n        <Dself>.<Aoutput_pid>(<Dsys>.<Dstderr>, <S\"Worker running Mac pre-processing on file: %s\"> % (<Dfile>,))\n\n        <C# our return is a status and a tuple of files to dump symbols for>\n<C>        <C# the extra files are fallbacks; as soon as one is dumped successfully, we stop>\n<C>        <Dresult> = { <S'status'> : <VFalse,> <S'files'> : <VNone,> <S'file_key'> : <Dfile> }\n        <Adsymbundle> = <Dfile> + <S\".dSYM\">\n        <Vif ><Dos>.<Dpath>.<Dexists>(<Adsymbundle>):\n            <Ashutil>.<Armtree>(<Adsymbundle>)\n        <C# dsymutil takes --arch=foo instead of -a foo like everything else>\n<C>        <Dsubprocess>.<Dcall>([<S\"dsymutil\">] + [<Da>.<Dreplace>(<S'-a '>, <S'--arch='>) <Vfor ><Da> <Vin ><Dself>.<Aarchs> <Vif ><Da>]\n                        + [<Dfile>],\n                        <Dstdout>=<Dopen>(<S\"/dev/null\">,<S\"w\">))\n        <Vif ><Vnot ><Dos>.<Dpath>.<Dexists>(<Adsymbundle>):\n            <C# dsymutil won't produce a .dSYM for files without symbols>\n<C>            <Dself>.<Aoutput_pid>(<Dsys>.<Dstderr>, <S\"No symbols found in file: %s\"> % (<Dfile>,))\n            <Dresult>[<S'status'>] = <VFalse\n>            <Dresult>[<S'files'>] = (<Dfile>, )\n            <Vreturn ><Dresult>\n\n        <Dresult>[<S'status'>] = <VTrue\n>        <Dresult>[<S'files'>] = (<Adsymbundle>, <Dfile>)\n        <Vreturn ><Dresult>\n\n    <Vdef ><ACopyDebug>(<Dself>, <Dfile>, <Ddebug_file>, <Dguid>):\n        <S\"\"\"ProcessFiles has already produced a dSYM bundle, so we should just\n        copy that to the destination directory. However, we'll package it\n        into a .tar.bz2 because the debug symbols are pretty huge, and\n        also because it's a bundle, so it's a directory. |file| here is the\n        dSYM bundle, and |debug_file| is the original filename.\"\"\">\n        <Arel_path> = <Dos>.<Dpath>.<Djoin>(<Ddebug_file>,\n                                <Dguid>,\n                                <Dos>.<Dpath>.<Dbasename>(<Dfile>) + <S\".tar.bz2\">)\n        <Dfull_path> = <Dos>.<Dpath>.<Dabspath>(<Dos>.<Dpath>.<Djoin>(<Dself>.<Asymbol_path>,\n                                                  <Arel_path>))\n        <Dsuccess> = <Dsubprocess>.<Dcall>([<S\"tar\">, <S\"cjf\">, <Dfull_path>, <Dos>.<Dpath>.<Dbasename>(<Dfile>)],\n                                  <Dcwd>=<Dos>.<Dpath>.<Ddirname>(<Dfile>),\n                                  <Dstdout>=<Dopen>(<S\"/dev/null\">,<S\"w\">), <Dstderr>=<Dsubprocess>.<ASTDOUT>)\n        <Vif ><Dsuccess> == 0 <Vand ><Dos>.<Dpath>.<Dexists>(<Dfull_path>):\n            <Dself>.<Doutput>(<Dsys>.<Dstdout>, <Arel_path>)\n\n<C# Entry point if called as a standalone program>\n<C><Vdef ><Dmain>():\n    <Dparser> = <DOptionParser>(<Dusage>=<S\"usage: %prog [options] &lt;dump_syms binary&gt; &lt;symbol store path&gt; &lt;debug info files&gt;\">)\n    <Dparser>.<Aadd_option>(<S\"-c\">, <S\"--copy\">,\n                      <Daction>=<S\"store_true\">, <Ddest>=<S\"copy_debug\">, <Adefault>=<VFalse,>\n                      <Dhelp>=<S\"Copy debug info files into the same directory structure as symbol files\">)\n    <Dparser>.<Aadd_option>(<S\"-a\">, <S\"--archs\">,\n                      <Daction>=<S\"store\">, <Ddest>=<S\"archs\">,\n                      <Dhelp>=<S\"Run dump_syms -a &lt;arch&gt; for each space separated cpu architecture in ARCHS (only on OS X)\">)\n    <Dparser>.<Aadd_option>(<S\"-s\">, <S\"--srcdir\">,\n                      <Daction>=<S\"append\">, <Ddest>=<S\"srcdir\">, <Adefault>=[],\n                      <Dhelp>=<S\"Use SRCDIR to determine relative paths to source files\">)\n    <Dparser>.<Aadd_option>(<S\"-v\">, <S\"--vcs-info\">,\n                      <Daction>=<S\"store_true\">, <Ddest>=<S\"vcsinfo\">,\n                      <Dhelp>=<S\"Try to retrieve VCS info for each FILE listed in the output\">)\n    <Dparser>.<Aadd_option>(<S\"-i\">, <S\"--source-index\">,\n                      <Daction>=<S\"store_true\">, <Ddest>=<S\"srcsrv\">, <Adefault>=<VFalse,>\n                      <Dhelp>=<S\"Add source index information to debug files, making them suitable for use in a source server.\">)\n    <Dparser>.<Aadd_option>(<S\"-x\">, <S\"--exclude\">,\n                      <Daction>=<S\"append\">, <Ddest>=<S\"exclude\">, <Adefault>=[], <Dmetavar>=<S\"PATTERN\">,\n                      <Dhelp>=<S\"Skip processing files matching PATTERN.\">)\n    <Dparser>.<Aadd_option>(<S\"--repo-manifest\">,\n                      <Daction>=<S\"store\">, <Ddest>=<S\"repo_manifest\">,\n                      <Dhelp>=<S\"\"\"Get source information from this XML manifest\nproduced by the `repo manifest -r` command.\n\"\"\">)\n    (<Doptions>, <Dargs>) = <Dparser>.<Dparse_args>()\n\n    <C#check to see if the pdbstr.exe exists>\n<C>    <Vif ><Doptions>.<Asrcsrv>:\n        <Apdbstr> = <Dos>.<Denviron>.<Dget>(<S\"PDBSTR_PATH\">)\n        <Vif ><Vnot ><Dos>.<Dpath>.<Dexists>(<Apdbstr>):\n            <Dprint> &gt;&gt; <Dsys>.<Dstderr>, <S\"Invalid path to pdbstr.exe - please set/check PDBSTR_PATH.\\n\">\n            <Dsys>.<Dexit>(1)\n\n    <Vif ><Dlen>(<Dargs>) &lt; 3:\n        <Dparser>.<Derror>(<S\"not enough arguments\">)\n        <Dexit>(1)\n\n    <Ddumper> = <AGetPlatformSpecificDumper>(<Adump_syms>=<Dargs>[0],\n                                       <Asymbol_path>=<Dargs>[1],\n                                       <Acopy_debug>=<Doptions>.<Acopy_debug>,\n                                       <Aarchs>=<Doptions>.<Aarchs>,\n                                       <Asrcdirs>=<Doptions>.<Dsrcdir>,\n                                       <Avcsinfo>=<Doptions>.<Avcsinfo>,\n                                       <Asrcsrv>=<Doptions>.<Asrcsrv>,\n                                       <Dexclude>=<Doptions>.<Dexclude>,\n                                       <Arepo_manifest>=<Doptions>.<Arepo_manifest>)\n    ");
</script><script>addCode("<Vfor ><Darg> <Vin ><Dargs>[2:]:\n        <Ddumper>.<DProcess>(<Darg>)\n    <Ddumper>.<DFinish>()\n\n<C# run main if run directly>\n<C><Vif ><A__name__> == <S\"__main__\">:\n    <C# set up the multiprocessing infrastructure before we start;>\n<C>    <C# note that this needs to be in the __main__ guard, or else Windows will choke>\n<C>    <DDumper>.<DGlobalInit>()\n\n    <Dmain>()\n");
</script></span></pre><form name='revs' id='revs' class='aftercontent'
>view http://hg.mozilla.org/mozilla-central/rev/
<select name='rev' id='rev' onchange='changerev()'>
<option value="5f32fc157fea">5f32fc157fea (2013-06-10 11:01 -0400) Todd Whiteman</option>
<option value="2b526c0d0b58">2b526c0d0b58 (2013-04-26 15:30 -0400) Ted Mielczarek</option>
<option value="8d4bdcbc68c7">8d4bdcbc68c7 (2013-04-25 15:15 -0400) Ted Mielczarek</option>
<option value="26954234c778">26954234c778 (2012-12-27 15:32 -0800) Benedict Singer</option>
<option value="4b1328bd377c">4b1328bd377c (2012-12-16 22:25 -0500) Ryan VanderMeulen</option>
<option value="11bf35befda6">11bf35befda6 (2012-12-11 09:52 -0500) Benedict Singer</option>
<option value="d62b457df9a7">d62b457df9a7 (2012-12-09 09:33 +0100) Mike Hommey</option>
<option value="3bb2d53dde34">3bb2d53dde34 (2012-12-06 17:06 +0100) Mike Hommey</option>
<option value="caca2267f82b">caca2267f82b (2012-10-29 11:12 -0400) Ted Mielczarek</option>
<option value="69b34a83ee61">69b34a83ee61 (2012-10-29 11:12 -0400) Ted Mielczarek</option>
<option value="6afd61ba31de">6afd61ba31de (2012-08-07 11:32 +1000) Mark Hammond</option>
<option value="32a058c88ce8">32a058c88ce8 (2012-06-21 09:02 -0400) Ted Mielczarek</option>
<option value="38fc0b6b4e62">38fc0b6b4e62 (2012-06-19 09:24 -0400) Ted Mielczarek</option>
<option value="602cfef02b3d">602cfef02b3d (2012-05-24 11:58 -0400) Ted Mielczarek</option>
<option value="120561214943">120561214943 (2012-05-25 15:21 -0400) Ted Mielczarek</option>
<option value="4566522a1bfd">4566522a1bfd (2012-05-24 11:58 -0400) Ted Mielczarek</option>
<option value="a70c497939cf">a70c497939cf (2012-04-25 13:37 -0400) Ted Mielczarek</option>
<option value="f4157e8c4107">f4157e8c4107 (2012-05-21 12:12 +0100) Gervase Markham</option>
<option value="9fdd1e53e1d0">9fdd1e53e1d0 (2012-05-16 14:51 -0400) Dustin J. Mitchell</option>
<option value="e55c365618ab">e55c365618ab (2012-04-04 20:03 +0200) Wolfgang Rosenauer</option>
<option value="348e16153987">348e16153987 (2011-10-06 09:08 +0200) Mike Hommey</option>
<option value="ce8c5b97125c">ce8c5b97125c (2010-07-26 13:12 +1200) Ted Mielczarek</option>
<option value="0f3542a15b5b">0f3542a15b5b (2010-07-18 11:16 +0200) Ryan VanderMeulen</option>
<option value="722556e1b9f5">722556e1b9f5 (2010-05-18 12:46 -0400) Ted Mielczarek</option>
<option value="96b2fb480110">96b2fb480110 (2009-10-03 14:52 -0400) Ted Mielczarek</option>
<option value="7f0988f042e9">7f0988f042e9 (2009-09-14 22:37 +1200) Lukas Blakk</option>
<option value="19e50a3ed48c">19e50a3ed48c (2009-06-12 14:50 +0200) Florian Queze</option>
<option value="132f022dcdd0">132f022dcdd0 (2009-03-16 16:46 -0400) Ted Mielczarek</option>
<option value="dbd5b5c6710c">dbd5b5c6710c (2009-03-11 11:56 -0400) Ted Mielczarek</option>
<option value="d2d0110cd69a">d2d0110cd69a (2009-02-17 07:46 +0000) Philippe M. Chiasson</option>
<option value="db2cabebef39">db2cabebef39 (2009-01-23 07:40 -0500) Ted Mielczarek</option>
<option value="30ee44d51589">30ee44d51589 (2008-12-24 14:04 -0500) Ted Mielczarek</option>
<option value="9410ad10c6f7">9410ad10c6f7 (2008-12-19 11:04 -0500) Jesse Valianes</option>
<option value="99dca5692399">99dca5692399 (2008-12-09 16:19 -0500) Ted Mielczarek</option>
<option value="ede5b83266d3">ede5b83266d3 (2008-12-08 12:04 -0500) Ted Mielczarek</option>
<option value="10e63a02fbc9">10e63a02fbc9 (2008-07-17 13:19 -0400) Lukas Blakk</option>
<option value="2e5a4595e7af">2e5a4595e7af (2008-06-18 11:06 -0400) Ted Mielczarek</option>
<option value="bd2afa077f6e">bd2afa077f6e (2008-04-15 03:31 -0700) ted mielczarek</option>
<option value="c8f66098b4df">c8f66098b4df (2008-04-08 23:39 -0700) reed</option>
<option value="058bc6416e31">058bc6416e31 (2008-04-04 12:53 -0700) ted mielczarek</option>
<option value="762dd6c7a762">762dd6c7a762 (2008-04-04 01:54 -0700) reed</option>
<option value="9ccf387500ff">9ccf387500ff (2008-03-19 18:13 -0700) alfred peng</option>
<option value="baca1b145d51">baca1b145d51 (2008-03-06 04:15 -0800) ted mielczarek</option>
<option value="a601d67a0717">a601d67a0717 (2008-02-26 16:54 -0800) reed</option>
<option value="551de77da951">551de77da951 (2007-10-11 14:54 -0700) bent mozilla</option>
<option value="4a0bf3661f04">4a0bf3661f04 (2007-09-26 11:01 -0700) bent mozilla</option>
<option value="460590707584">460590707584 (2007-08-22 13:47 -0700) ted mielczarek</option>
<option value="13fe21f354ea">13fe21f354ea (2007-08-13 13:35 -0700) bent mozilla</option>
<option value="45d7919dc8a1">45d7919dc8a1 (2007-07-24 18:06 -0700) ted mielczarek</option>
<option value="53ca657ec478">53ca657ec478 (2007-07-24 18:06 -0700) ted mielczarek</option>
<option value="f62599e462c8">f62599e462c8 (2007-07-24 18:06 -0700) ted mielczarek</option>
<option value="83bb708b3557">83bb708b3557 (2007-07-24 18:06 -0700) ted mielczarek</option>

</select>/toolkit/crashreporter/tools/symbolstore.py
</form>
</p>

</html>
